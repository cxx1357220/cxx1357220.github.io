<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[今天，某天]]></title>
    <url>%2F2018%2F08%2F03%2F%E4%BB%8A%E5%A4%A9%EF%BC%8C%E6%9F%90%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[今天，跟同事聊天，突然聊到年纪，你24了呀。不，我23我23！不管怎么样，突然觉得自己老了，回想着自己18岁的样子，或许那个夏天也像现在那样燥热，做下决定的时候根本不会意识到会对人生造成多大的改变。可能年轻就是这样，不管如何在日记中也不过是轻描淡写的一天。]]></content>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx部署简单的vue项目]]></title>
    <url>%2F2018%2F07%2F28%2Fnginx%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[centos7安装nginx 安装nginx包 1rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装nginx 1yum install -y nginx 查看nginx是否能启动 1systemctl start nginx.service 没什么问题，把它添加到系统开机启动项中 1systemctl enable nginx.service 有问题的话，查看问题并修改 1systemctl status nginx.service 在浏览器输入服务器地址，出现内容就算成了。不成的话可以试试修改防火墙: 123sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload vue生产 vue打包 1npm run build 把打包好的dist文件里边的文件放到/home/vue里边去（我喜欢放这，仅此而已），然后把/home及其下文件权限设置为777。 nginx配置 查看nginx目录 1whereis nginx 配置文件应该在/etc/nginx下，修改配置文件 12345cd /etc/nginxlscd /conf.dlsvi default.conf 看到配置 12345678910111213141516171819202122232425262728server &#123; listen 80; //端口 server_name localhost; //网站名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; //可以看到默认的登陆log存放路径，但配置是写在nginx.conf中的，error路径也在此 location / &#123; #root /usr/share/nginx/html; //默认的站点目录 root /home/vue; //更改站点目录到/home/vue里边 index index.html index.htm; //主页文件 &#125; location /api &#123; //设置根目录下/api跨域代理 add_header 'Access-Control-Allow-Origin' '*'; //允许跨域 proxy_pass https://cnodejs.org/api/v1; //跨域地址 &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; tip:按下i进入修改，esc退出，输入:wq!保存。w保存，q退出，!强制。 这时候访问网站却弹出403，尝试修改nginx配置：nginx.conf 123cd /etc/nginxlsvi nginx.conf 编辑 1234567891011#user nginx; #注释掉以前的user root; #把用户修改成rootworker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;.....一些配置参数，default.conf也是在此引入的.............. 还是403，关闭SELinux 1vi /etc/selinux/config 把里边的改为SELINUX=disabled，然后重启（reboot）掉服务器生效。 nginx部署两个项目引发的路径问题nginx conf配置url路径名称必须和/home/下文件夹vue-element-admin一致12345678910111213141516 location /cnode &#123; #root /usr/share/nginx/html;root /home/; index index.html index.htm; &#125; location /api &#123;add_header 'Access-Control-Allow-Origin' '*'; proxy_pass https://cnodejs.org/api/v1; &#125; location /vue-element-admin &#123; #此路径名称必须和/home/下文件夹vue-element-admin一致 #root /usr/share/nginx/html;root /home/; index index.html index.htm; &#125; 静态资源加载404由于资源已不在根目录下，所以需要更改配置index.js里边的build的路径，比如此项目在/home/vue-element-admin/文件夹下。1assetsPublicPath: '/vue-element-admin/', // If you are deployed on the root path, please use '/']]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳跃数组]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%B7%B3%E8%B7%83%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[仅供个人学习，如有错误请指出 123456//给定一个非负数整数数组，最初位于数组的第一个索引处。//数组中的每个元素表示在该位置的最大跳跃长度。//确定是否能够到达最后一个索引。//示例://A = [2,3,1,1,4], 返回 true//B = [2,3,1,0,4], 返回 false 12345678910111213141516171819202122/*** arr_index 数组跳跃算法 &amp;&amp;testNumber(arr[0])* @param &#123;Array&#125; arr 数组*/var arr_index=(arr)=&gt;&#123; if(arr[0]==(arr.length-1))&#123; return true; &#125;else&#123; if(arr[arr[0]]&amp;&amp;arr[0]!=0)&#123; //arr[arr[0]]真好用，无论是否为空，是否为正整数都解决掉了 return arr_index(arr.slice(arr[0])); &#125;else&#123; return false; &#125; &#125;&#125;console.log(arr_index([2,,1]));console.log(arr_index(['un',1]));console.log(arr_index([]));console.log(arr_index([1]));console.log(arr_index([0]));console.log(arr_index([2,'UN','UN']));console.log(arr_index([-1,'UN','UN']));]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近写自适应想起的几个css]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%80%E8%BF%91%E5%86%99%E8%87%AA%E9%80%82%E5%BA%94%E6%83%B3%E8%B5%B7%E7%9A%84%E5%87%A0%E4%B8%AAcss%2F</url>
    <content type="text"><![CDATA[vh vw vminvw为相对于视窗的宽度，vh为相对于视窗的高度，vm为相对于视窗高或者宽中的最小值。视窗的宽高为100vw,100vh。 calccalc()函数支持 “+”, “-“, “*”, “/“ 运算；calc()函数使用标准的数学运算优先级规则； 123img&#123; width: calc(100% - 10px);&#125; @media针对不同的屏幕尺寸设置不同的样式，重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 一些代码12345678910111213141516171819@media screen and (max-width:420px) &#123; img &#123; height: 100vh; width: 100%; &#125;&#125;@media screen and (min-width: 420px) and (max-height: 700px) &#123; img &#123; max-width: 420px; height: 100vh; width: 100%; &#125;&#125;@media screen and (min-width: 700px) and (min-height: 1000px) &#123; img &#123; height: 100vh; width: 100%; &#125;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组扁平化去重排序]]></title>
    <url>%2F2018%2F07%2F01%2F%E6%89%81%E5%B9%B3%E5%8C%96%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[仅供个人学习，如有错误请指出 扁平化，去重，排序1234567891011let arr=[[1,5,1,2],[2,3,4]];//排序const arr_sort = arr =&gt; arr.sort((a, b) =&gt;a - b);//扁平化const flat = arr =&gt; arr.toString().split(',').map(x=&gt;parseFloat(x)); //toString()先转化为字符串，split(',')再根据'，'号分割成字符串,map(x=&gt;parseFloat(x))最后转化为数字，从而实现扁平化const flatten = arr =&gt; arr.reduce((a, b) =&gt; a.concat(Array.isArray(b) ? flatten(b) : b), []);//reduce遍历，concat扁平化一层//es6去重const removal = arr =&gt;Array.from(new Set(arr));// new Set()去重，array.from()将set转为真正的数组const rm =arr =&gt; [...new Set(arr)]; //扩展运算符也可以将set结构转化为数组 简化1234567//第一种const arr_handle = arr =&gt; Array.from(new Set(arr.toString().split(',').map(x=&gt;parseFloat(x)))).sort((a, b) =&gt;a - b); //第二种const arr_handle1 = arr =&gt; &#123;let flatten = arr =&gt; arr.reduce((a, b) =&gt; a.concat(Array.isArray(b)? flatten(b): b), []);return [...new Set(flatten(arr))].sort((a, b) =&gt; a &gt; b);&#125;;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由基础]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[仅供个人学习，如有错误欢迎指出。 vue路由1234567891011import Index from '../pages/index.vue'export default new Router(&#123; routes: [ &#123; path: '/', //默认路径 name: 'Index', //便于路由跳转 component: Index, //组件 &#125; ]&#125;) vue路由跳转并获取参数第一种方法params：1234//跳转传值：this.$router.push(&#123;name:'Index',params:&#123;name:'xy',age:22&#125;&#125;);//获取参数：this.$route.params.name; //xy 第二种方法query:1234//跳转传值：this.$router.push(&#123;name:'Index',query:&#123;name:'xy',age:22&#125;&#125;);//获取参数：this.$route.query.age; //22 vue嵌套路由 组件是一个 functional 组件，渲染路径匹配到的视图组件。 渲染的组件还可以内嵌自己的 ，根据嵌套路径，渲染嵌套组件。借助 vue-router，使用嵌套路由，嵌套的组件children在中渲染。 12345&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 给视图命名可以对应渲染出口 --&gt; &lt;router-view name="order"&gt;&lt;/router-view&gt;&lt;/div&gt; 嵌套路由1234567891011121314151617181920import Index from '../pages/index.vue'import order from '../pages/order.vue'export default new Router(&#123; routes: [ &#123; path: '/', //默认路径 name: 'Index', //便于路由跳转 component: Index, //组件 children：[&#123; path: '/', //'/'下，默认加载 name: 'order', //便于路由跳转 component: &#123; default: order, //组件,没有name的&lt;router-view&gt;默认的为default order: order //对应name='order'的&lt;router-view&gt; &#125; &#125;] &#125; ]&#125;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慢慢逝去的一天]]></title>
    <url>%2F2018%2F06%2F23%2F%E5%A4%B1%E5%8E%BB%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[看了一天微信小游戏，得了个结论：先看小程序吧。。。]]></content>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理移动端click事件300毫秒延迟]]></title>
    <url>%2F2018%2F06%2F15%2F%E5%A4%84%E7%90%86%E7%A7%BB%E5%8A%A8%E7%AB%AFclick%E4%BA%8B%E4%BB%B6300%E6%AF%AB%E7%A7%92%E5%BB%B6%E8%BF%9F%2F</url>
    <content type="text"><![CDATA[仅为个人学习之用，如有错误欢迎指出 从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。为什么这么设计呢？ 因为它想看看你是不是要进行双击（double tap）操作。 FastClickFastClick是移动端click事件300毫秒延迟的一种解决方案。github地址 vue在vue的安装 1npm install fastclick --save 在vue的使用：main.js文件中引入并绑定到body中。 12import FastClick from 'fastclick'FastClick.attach(document.body) jQuery在jQuery的安装应用 12345//引入FastClick.js文件$(function() &#123; FastClick.attach(document.body);&#125;); 普通模式在基础js下安装使用 12345//引入FastClick.js文件window.addEventListener(function()&#123; FastClick.attach( document.body ); &#125;,false );]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为啥不随便用for-in]]></title>
    <url>%2F2018%2F06%2F08%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%8E%E7%94%A8for-in%2F</url>
    <content type="text"><![CDATA[仅供个人学习，如有错误请指出 for-in的输出排序当数组中有0和正整数的key时，输出排序被改变，因为for-in会先对这些keys进行排序1234567891011121314151617var obj=&#123; "first":"first", "3.1":"3.1", "-2":"-2", "34":"34", "1":"1", "second":"second", '001':'001'&#125;;for (var i in obj) &#123; console.log(i); &#125;;//1//34//first//3.1//-2//second//001 不想改变排序那怎么办我还没找到方法，只能希望key不是0和正整数了。 for-in对属性的操作12345678910111213141516171819var obj=&#123; "first":"first", "3.1":"3.1", "-2":"-2", "34":"34", "1":"1", "second":"second", '001':'001'&#125;;Object.prototype.age=13; //给所有object添加属性age等于13for (var i in obj) &#123; console.log(i+":"+obj[i]); &#125;;//1:1//34:34//first:first//3.1:3.1//-2:-2//second:second//001:001//age:13 //把属性输出了。。。 不想输出属性那怎么办123456789101112var obj=&#123; "first":"first", "3.1":"3.1", "-2":"-2", "34":"34", "1":"1", "second":"second", '001':'001'&#125;;Object.prototype.age=13; Object.keys(obj);//Object.getOwnPropertyNames(obj);同效果//(7) ["1", "34", "first", "3.1", "-2", "second", "001"] 说那么多，我只要value1234567891011121314151617181920212223var obj=&#123; "first":"first", "3.1":"3.1", "-2":"-2", "34":"34", "1":"1", "second":"second", '001':'001'&#125;;Object.prototype.age=13; for (var key of Object.keys(obj)) &#123; console.log(key + ': ' + obj[key]);&#125;//1: 1//34: 34//first: first//3.1: 3.1//-2: -2//second: second//001: 001Object.values(obj);//(7) ["1", "34", "first", "3.1", "-2", "second", "001"] 对象都那么麻烦，数组呢用都不要用，for-in就是为了对象设计的，用于对象都挺麻烦的。 用在数组上有更方便高效的方法：1234567var myArray = [1,2,3,4,5];for (let index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125;for (let i of myArray) &#123; console.log(i);&#125; 偏偏是最原始的方法效率高，for-of看起来整洁，但效率比for要低。1234567891011121314151617181920var n = 10000;// 准备待测数组var arr = [];for(var count=0;count&lt;n;count++)&#123; arr[count] = 1;&#125;// for 测试console.time('for');for(var i=0;i&lt;arr.length;i++)&#123; arr[i];&#125;console.timeEnd('for');// for in 测试console.time('for of');for(var item of arr)&#123; arr[item];&#125;console.timeEnd('for of');]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yaf默认路由学习]]></title>
    <url>%2F2018%2F06%2F01%2Fyaf%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[仅为个人学习之用，如有错误，欢迎指出。 yaf为mvc框架yaf默认的路由协议Yaf_Route_Static, 就是分析请求中的request_uri, 在去除掉base_uri以后, 获取到真正的负载路由信息的request_uri片段, 具体的策略是, 根据”/“对request_uri分段, 依次得到Module,Controller,Action。 1234567891011121314151617181920- index.php //入口文件 - .htaccess //重写规则 + conf - application.ini //配置文件，新建模块需要事先在里边声明 application/ + controllers - Index.php //默认控制器 + views + index //控制器 - index.phtml //默认视图 + modules //其他模块 + Admin //模块Module + controllers - User.php //控制器Controller,在里编写了Action，indexAction控制index.phtml + views + user //控制器 - index.twig //视图，默认为.phtml可以通过插件换为html，twig - library //本地类库 - models //model目录 - plugins //插件目录 yaf新建模块声明在conf/application.ini中修改加上： 1application.modules = Index,Admin 控制器Controller1234567891011121314151617/** * Controller * * @return bool */class UserController extends ControllerAbstract&#123; /** * index的Action * * @return bool */ public function indexAction()&#123; $this-&gt;getView()-&gt;assign('refundFee', '123'); //输出到页面 return true; &#125;&#125; 视图index.twig123456&lt;body&gt;&lt;div&gt;&lt;!-- 输出123 --&gt;&#123;&#123;refundFee&#125;&#125; &lt;/div&gt;&lt;/body&gt; 访问地址http:// .base_uri. /admin/user/index 请求该地址不需要绑定视图也可以直接访问。 Controller和Action： 123456789101112131415161718192021222324252627282930/** * Controller * * @return bool */class UserController extends ControllerAbstract&#123; /** * index的Action * * @return bool */ public function indexAction()&#123; $this-&gt;getView()-&gt;assign('refundFee', '123'); //输出到页面 return true; &#125; /** * 加载应用列表 * * @return bool */ public function appAction()&#123; $apptable=MessageConfigModel::all(); //查询 $result = ['code' =&gt; 0, 'msg' =&gt; '查询成功', 'data' =&gt; $apptable]; $this-&gt;out($result); //json输出 return true; &#125;&#125; 访问地址：http:// .base_uri. /admin/user/app 得到的： {“code”:0,”msg”:”查询成功”,”data”:[…]} 一般用于请求，例如ajax请求： 12345678910111213$.ajax(&#123; url:'http:// .base_uri. /admin/user/app', type:'POST', dataType:'JSON', data:&#123;&#125;, async:false, success:function (data) &#123; console.log(data); //&#123;code:0,msg:'查询成功',data:[...]&#125; &#125;, error:function(e)&#123; console.log(e); &#125;&#125;); 参考文档：官方文档]]></content>
      <tags>
        <tag>php</tag>
        <tag>yaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信H5支付]]></title>
    <url>%2F2018%2F05%2F31%2Fwx_H5_pay%2F</url>
    <content type="text"><![CDATA[仅为个人学习之用，如有错误欢迎指出 看了好久微信文档，心里万马奔腾。 先获取用户code官方文档1https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URL&amp;response_type=code&amp;scope=snsapi_base#wechat_redirect 参数说明：appid：公众号的唯一标识，可以登录到公众平台查看redirect_uri：授权后重定向的回调链接地址，先使用 urlEncode 对链接进行处理，打开个在线转译的转成urlEncode粘贴过来就行了。response_type：返回类型，请填写code，必须是’code’。scope：应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ）state：重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节（非必需）。 #wechat_redirect：无论直接打开还是做页面302重定向时候，必须带此参数（必须）。 根据用户code获取用户与公众号之间关系的openid官方文档请求该地址：1https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 参数说明：appid：公众号的唯一标识，可以登录到公众平台查看。secret：公众号的appsecret，可以登录到公众平台查看。code：填写第一步获取的code参数。grant_type：填写为authorization_code，必须是’authorization_code’。 返回值为json数组：12345&#123; "access_token":"ACCESS_TOKEN", //网页授权接口调用凭证"expires_in":7200, //access_token接口调用凭证超时时间"refresh_token":"REFRESH_TOKEN", //用户刷新access_token"openid":"OPENID", //根据用户code获取用户与公众号之间关系的openid"scope":"SCOPE" &#125; //用户授权的作用域，使用逗号（,）分隔 根据openid获取到预支付交易会话标识prepay_id官方文档请求该地址返回prepay_id1https://api.mch.weixin.qq.com/pay/unifiedorder 参数说明：xml串：12345678910111213&lt;xml&gt; &lt;appid&gt;wx2421b1c4370ec43b&lt;/appid&gt; 微信支付分配的公众账号ID &lt;body&gt;nfyy&lt;/body&gt; 商品描述 &lt;mch_id&gt;10000100&lt;/mch_id&gt; 微信支付分配的商户号 &lt;nonce_str&gt;1add1a30ac87aa2db72f57a2375d8fec&lt;/nonce_str&gt; 随机字符串32位以内 &lt;notify_url&gt;http://www.baidu.php&lt;/notify_url&gt; 异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。 &lt;openid&gt;oUpF8uMuAJO_M2pxb1Q9zNjWeS6o&lt;/openid&gt; 微信用户在商户对应appid下的唯一标识 &lt;out_trade_no&gt;1415659990&lt;/out_trade_no&gt; 商户订单号，同商户下唯一 &lt;spbill_create_ip&gt;14.23.150.211&lt;/spbill_create_ip&gt; 用户ip地址 &lt;total_fee&gt;1&lt;/total_fee&gt; 交易金额，只能为正整数，不能有千分位，单位为分。 &lt;trade_type&gt;JSAPI&lt;/trade_type&gt; 交易类型，JSAPI为公众号支付 &lt;sign&gt;0CB01533B8C1EF103065174F50BCA001&lt;/sign&gt; 签名，根据以上的参数和公众号商户的唯一密匙key拼接加密而成&lt;/xml&gt; 这边有两个问题，一个是用户ip的获取，一个是签名生成的方法，还有个坑就是，里边必须为UTF-8格式，不然会报错。 获取用户的ip（spbill_create_ip）在后端php实现123456789101112131415161718192021222324function get_client_ip($type = 0) &#123; $type = $type ? 1 : 0; static $ip = NULL; if ($ip !== NULL) return $ip[$type]; if($_SERVER['HTTP_X_REAL_IP'])&#123;//nginx 代理模式下，获取客户端真实IP $ip=$_SERVER['HTTP_X_REAL_IP']; &#125;elseif (isset($_SERVER['HTTP_CLIENT_IP'])) &#123;//客户端的ip $ip = $_SERVER['HTTP_CLIENT_IP']; &#125;elseif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123;//浏览当前页面的用户计算机的网关 $arr = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $pos = array_search('unknown',$arr); if(false !== $pos) unset($arr[$pos]); $ip = trim($arr[0]); &#125;elseif (isset($_SERVER['REMOTE_ADDR'])) &#123; $ip = $_SERVER['REMOTE_ADDR'];//浏览当前页面的用户计算机的ip地址 &#125;else&#123; $ip=$_SERVER['REMOTE_ADDR']; &#125; // IP地址合法验证 $long = sprintf("%u",ip2long($ip)); $ip = $long ? array($ip, $long) : array('0.0.0.0', 0); return $ip[$type];&#125;$user_ip = get_client_ip(); //获取ip到$user_ip 签名算法官方文档测试地址◆ 参数名ASCII码从小到大排序（字典序）；◆ 如果参数的值为空不参与签名；◆ 参数名区分大小写；12345678910111213141516171819202122$data = array( 'appid' =&gt; 'wx2421b1c4370ec43b', //微信支付分配的公众账号ID 'body' =&gt; 'nfyy', //商品描述 'mch_id' =&gt; '10000100', //微信支付分配的商户号 'nonce_str' =&gt; '1add1a30ac87aa2db72f57a2375d8fec', //随机字符串 'notify_url' =&gt; 'http://www.baidu.php', //异步回调地址 'out_trade_no' =&gt; '1415659990' //商户订单号，同商户下唯一 'openid' =&gt; 'oUpF8uMuAJO_M2pxb1Q9zNjWeS6o', //用户登录时获取的code中含有的值 'spbill_create_ip' =&gt; $user_ip, //网页支付提交用户端ip 'total_fee' =&gt; 0.01 * 100, //订单总额单位为分 'trade_type' =&gt; 'JSAPI' //交易类型);$key = 'z4hgl4cnk5p0x3aiy2ycf5ac2wl3msie'; //商户秘钥ksort($data); //按照参数名ASCII码从小到大排序（字典序）；$joint = ""; //拼接foreach ($data as $k =&gt; $v) &#123; //循环拼接 $joint .= $k . "=" . $v . "&amp;";&#125;$stringSignTemp = $joint."key=".$key; //加上商户密匙$sign=MD5($stringSignTemp);//MD5加密$sign=strtoupper($sign); //转为大写$data['sign'] = $sign; //加到数组中去 prepay_id返回值1234567891011121314151617&lt;xml&gt; &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt; &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt; &lt;appid&gt;&lt;![CDATA[wx2421b1c4370ec43b]]&gt;&lt;/appid&gt; &lt;mch_id&gt;&lt;![CDATA[10000100]]&gt;&lt;/mch_id&gt; &lt;nonce_str&gt;&lt;![CDATA[IITRi8Iabbblz1Jc]]&gt;&lt;/nonce_str&gt; &lt;openid&gt;&lt;![CDATA[oUpF8uMuAJO_M2pxb1Q9zNjWeS6o]]&gt;&lt;/openid&gt; &lt;sign&gt;&lt;![CDATA[7921E432F65EB8ED0CE9755F0E86D72F]]&gt;&lt;/sign&gt; &lt;result_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/result_code&gt; &lt;prepay_id&gt;&lt;![CDATA[wx201411101639507cbf6ffd8b0779950874]]&gt;&lt;/prepay_id&gt; &lt;trade_type&gt;&lt;![CDATA[JSAPI]]&gt;&lt;/trade_type&gt;&lt;/xml&gt;$str = Tools::curl($url,'POST',$xml); //获取返回的xml串$obj = simplexml_load_string($str, 'SimpleXMLElement', LIBXML_NOCDATA); //精简掉cdata$eJSON = json_encode($obj); //转化为json数组$dJSON = json_decode($eJSON); //转化为json数组$prepay_id = $dJSON-&gt;prepay_id;//获取"prepay_id"对应的值 调用微信的支付官方文档 12345678$timeStamp=time();$dataend = array( 'appId' =&gt; $app_id, //微信支付分配的公众账号ID 'timeStamp' =&gt;$timeStamp, //时间戳 'nonceStr' =&gt; $nonceStr, //随机的32位一下数 'package' =&gt; 'prepay_id=' . $prepay_id, //新获取的 'signType' =&gt; 'MD5', //加密方式); 123456789101112131415161718192021222324252627function onBridgeReady()&#123; WeixinJSBridge.invoke( 'getBrandWCPayRequest', &#123; "appId":&#123;&#123;appId&#125;&#125;, //公众号名称，由商户传入 "timeStamp":&#123;&#123;timeStamp&#125;&#125;, //时间戳，自1970年以来的秒数 "nonceStr":&#123;&#123;nonceStr&#125;&#125;, //随机串 "package":&#123;&#123;package&#125;&#125;, "signType":"MD5", //微信签名方式： "paySign":&#123;&#123;paySign&#125;&#125; //微信签名 &#125;, function(res)&#123; if(res.err_msg == "get_brand_wcpay_request:ok" ) &#123;&#125; // 使用以上方式判断前端返回,微信团队郑重提示：res.err_msg将在用户支付成功后返回 ok，但并不保证它绝对可靠。 &#125; ); &#125;if (typeof WeixinJSBridge == "undefined")&#123; if( document.addEventListener )&#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); &#125;else if (document.attachEvent)&#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); &#125;&#125;else&#123; onBridgeReady();&#125;//成了 获取时间戳1$timeStamp=time(); //获取时间戳 随机生成32位码12345678910function getRandom($param)&#123; //生成$param位随机数 $str="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; $strkey = ""; for($i=0;$i&lt;$param;$i++) &#123; $strkey .= $str&#123;mt_rand(0,32)&#125;; //生成php随机数 &#125; return $strkey;&#125;$getRandom = getRandom(32) xml.json互转1//工程里边有，懒得再写 坑记得要转码。 必须注意大小写，不然各种简明验证错误，比如appid和appId。 所有的加密都要一样，都用MD5就行。 在公众号配置好地址，支付地址只能在公众号配置地址最后一个参数可变化，比如：12www.demo.com/orderdemo/ //微信公众平台中授权url地址www.demo.com/orderdemo/demo //微信浏览器中允许访问的网址 SDK地址]]></content>
      <tags>
        <tag>js</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wamp的几个php扩展]]></title>
    <url>%2F2018%2F05%2F21%2Fwamp%E7%9A%84%E5%87%A0%E4%B8%AAphp%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[因工程需要用到的扩展：redis,seaslog,yaf 判断是TS还是NTS通过phpinfo(); 查看其中的 Thread Safety 项，这个项目就是查看是否是线程安全，如果是：enabled，一般来说应该是ts版，否则是nts版。 phpinfo() 安装配置把下载好的php_redis.dll, php_seaslog.dll, php_yaf.dll 放到D:\wamp64\bin\php\php7.0.23\ext里。 修改php.iniredis1extension=php_redis.dll seaslog1234567891011[SeasLog]extension=php_seaslog.dllseaslog.default_basepath=/log/seaslog-testseaslog.default_logger=defaultseaslog.disting_type=1seaslog.disting_by_hour=1seaslog.use_buffer=1seaslog.buffer_size=100seaslog.level=0seaslog.trace_error=1seaslog.trace_exception=0 yaf12345extension=php_yaf.dll[yaf]yaf.use_namespace = Onyaf.use_spl_autoload = 1 downloadyaf redis seaslog]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cnode几个作者下的文章]]></title>
    <url>%2F2018%2F05%2F15%2Fvue-cnode%2F</url>
    <content type="text"><![CDATA[仅供个人学习，如有错误请指出 安装下载1git clone https://github.com/cxx1357220/vue-cnode.git 安装12npm installnpm run dev 引入vuex和axios12npm install vuex --savenpm install axios -S 在main.js中引入12345import axios from 'axios'Vue.prototype.$axios = axios //这样写会使eslint报错，建议关闭import Vuex from 'vuex'Vue.use(Vuex) 关闭eslint找到build文件夹—&gt;webpack.base.conf.js—-&gt;module—-&gt;rules中与eslint相关的注释掉12345678module: &#123; rules: [ // ...(config.dev.useEslint ? [createLintingRule()] : []), &#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, 改变vuex里的数据，view里并不能监听到改变vuex里的数据，view里并不能监听到，所以用了watch，在computed中写一个计算属性listenTitle,返回状态管理中的headerTitle。然后在watch中监听这个计算属性的变化，对Header.vue中的headerTitle重新赋值。 123456789101112computed: &#123; listenTitle: &#123; get: function () &#123; return this.$store.state.headerTitle; &#125; &#125; &#125;, watch: &#123; listenTitle: function(a,b) &#123; this.headerTitle=a; &#125; &#125;, 嵌套路由index.js123456789101112export default new Router(&#123; routes: [&#123; path: '/', component: Index, name: 'Index', children: [ &#123; path: 'detail', component: Detail, name: 'detail' &#125;, &#123; path: '/', component: home, name: 'home' &#125;, &#123; path: 'article', component: article, name: 'article' &#125; ] &#125;]&#125;) Index.vue123456&lt;template&gt; &lt;div class="index"&gt; &lt;Header&gt;&lt;/Header&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 接口proxyTable更改config中的index.js里边的proxyTable 12345678910proxyTable: &#123; '/api': &#123; target: 'https://cnodejs.org', // 接口的域名 secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; '^/api': '/api/v1' //api &#125; &#125;&#125;, 在手机预览更改config中的index.js里边的host，同局域网下手机访问为’192.168.1.158:7777’ 12host: '192.168.1.158', // 更改此为你的ip地址port: 7777, // 端口，有可能冲突 组件传值原谅我都用了vuex，自从用了vuex，什么bus，props都觉得好难用。 效果,,,]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[twig日期转换]]></title>
    <url>%2F2018%2F05%2F08%2Ftwig%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[不同医院后台传出数据为3-2或者3-02，twig获取当前日期为03-02后台传出数据为3-2，twig获取当前日期为03-02，进行判断是否为当天的时候两者不相等，所以对后台传出数据在twig内进行转换。 具体为先转换成3/2格式再转换成03-02. 12345&lt;div&gt;&#123;&#123; '3-2'|replace(&#123;'-':'/'&#125;)|date('m-d')!='now'|date('m-d') &#125;&#125;&lt;/div&gt; &#123;% if '3-2'|replace(&#123;'-':'/'&#125;)|date('m-d')!='now'|date('m-d') %&#125; &lt;div&gt;&#123;&#123; '3-2'|replace(&#123;'-':'/'&#125;)|date('m-d') &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; 'now'|date('m-d') &#125;&#125;&lt;/div&gt; &#123;% endif %&#125;]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reverse()改变原有数组]]></title>
    <url>%2F2018%2F05%2F01%2Freverse%2F</url>
    <content type="text"><![CDATA[仅供个人学习，如有错误请指出 1234567891011const reverse_title=(arr)=&gt;&#123; let titleList=arr; return titleList.reverse();&#125;a=[1,2];//(2) [1, 2]b=reverse_title(a);//(2) [2, 1]a;//(2) [2, 1] 解决方法 1234567891011const reverse_title=(arr)=&gt;&#123; let titleList=arr; titleList=titleList.slice();//数组需要深度copy，不然reverse()会改变原数组 return titleList.reverse();&#125;a=[1,2];//(2) [1, 2]b=reverse_title(a);//(2) [2, 1]a;//(2) [1, 2]]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs获取cnode几个作者下的文章]]></title>
    <url>%2F2018%2F04%2F30%2Fnode_cnode%2F</url>
    <content type="text"><![CDATA[仅供个人学习，如有错误请指出 第一次体验nodejs。。。 直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115const axios = require('axios'), express = require('express'), app = express();var arr = 'JacksonTian,JacksonTian,imzengyang,JZLeung,six-666,vanishcode,chuanzai,huanz,zhangshiqiu,i5ting,Hyurl,D8Ge,spursy,wangchaoduo,JerrysShan,FrankDiao,heguangda,ITCNZ,yuu2lee4,jizhuofeng,MasterShu,2596887568,lvyueyang,lvyueyang,Aoqin,seekcx,zhunrong,vpntj,lovegnep,JerrysShan,vipzrx,hyrlh,superway117,zy445566,DoubleCG,liuzhiguo11,mrlong,quanpf2481,thebingepig,343830384';arr = Array.from(new Set(arr.split(",")));const api_url = 'https://cnodejs.org/api/v1/user/', article_url = 'https://cnodejs.org/topic/';arr_url = arr.map(x =&gt; api_url + x);const axios_out = (id) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; axios(&#123; method: 'get', url: article_url + id, &#125;) .then((response) =&gt; &#123; let match_topic_title = response.data.match(/(&lt;span class="topic_full_title"&gt;)([\s\r\n\t\S]*?)(&lt;div)/); //正则文章题目 let match_topic = response.data.match(/(&lt;div class='topic_content'&gt;)([\s\r\n\t\S]*?)(&lt;\/div&gt;)/); //正则文章div let words = [match_topic_title[2].replace(/&lt;\/?.+?&gt;/g, "").replace(/[\r\n\ +]/g, ""), match_topic[2].replace(/&lt;\/?.+?&gt;/g, "")]; //除去html标签 resolve(words); //传出成功状态参数 &#125;) .catch((error) =&gt; &#123; reject(error); &#125;); &#125;);&#125;;function timeout(ms) &#123; return new Promise((reject,resolve) =&gt; &#123;// (reject,resolve)这两个参数，谁第一个代表成功，第二个代表失败，无论取名如何。 setTimeout(()=&gt;&#123;resolve(ms+'ms内并发超时，执行继发')&#125;, ms); //给失败状态传值 &#125;);&#125;const get_list= async (id)=&gt;&#123; let article = &#123; id: id, &#125;; try &#123; article.words = await axios_out(id);//获取文章纯文本内容 &#125; catch (e) &#123; console.log('axios_out:' + id + ':' + e); return get_list(id); //失败后重新执行 &#125; return article;&#125;const try_arr = async (url) =&gt; &#123; try &#123; var get_axios = await axios.get(url); //axios为 Promise 对象 &#125; catch (e) &#123; console.log('try_arr' + e); &#125; let author_all = &#123;&#125;; //作者下的所有 try&#123; let arr_id = []; for (let i = 0; i &lt; get_axios.data.data.recent_topics.length; i++) &#123; arr_id.push(get_axios.data.data.recent_topics[i].id); &#125; var article_list = await Promise.race([Promise.all(arr_id.map(x=&gt;get_list(x))),timeout(5000)]); //设定时间内超时则传回失败状态。 &#125;catch(e)&#123; console.log(e); var article_list = []; //文章列表 for (let i = 0; i &lt; get_axios.data.data.recent_topics.length; i++) &#123; //循环插入文章id到文章列表 let article = &#123; id: get_axios.data.data.recent_topics[i].id, &#125;; //单条文章json try &#123; article.words = await axios_out(get_axios.data.data.recent_topics[i].id);//获取文章纯文本内容 &#125; catch (e) &#123; console.log('axios_out:' + get_axios.data.data.recent_topics[i].id + ':' + e) &#125; article_list.push(article); &#125; &#125; author_all.author = get_axios.data.data.loginname; //作者下的文章拼装成json author_all.article_list = article_list; return author_all; //输出&#125;;// const try_all = async function(arr)&#123; //promise.all封装// return Promise.all(arr.map(x=&gt;try_arr(x))); //只能所有的状态都为resolve，peomise.all的问题。// &#125;;const try_all = async (arr) =&gt; &#123; //继发，并发太多会触发服务器503 let arr_out = []; for (let i = 0; i &lt; arr.length; i++) &#123; try &#123; arr_out[i] = await try_arr(arr[i]); console.log('get:' + (i + 1)+'/'+arr.length + ':' + arr[i]); &#125; catch (e) &#123; console.log('error:' + (i + 1)+'/'+arr.length + ':' + arr[i]); arr_out[i] = e; &#125; &#125; return arr_out;&#125;;const listen = arr_url =&gt; &#123; try_all(arr_url).then(result =&gt; &#123; app.get('/', function (req, res) &#123; //express输出，http输出json报错 res.send(result); &#125;); var server = app.listen(8081,"127.0.0.1", function () &#123; var host = server.address().address, port = server.address().port; console.log("应用实例，访问地址为 http://%s:%s", host, port); &#125;); &#125;) .catch(e =&gt; console.log(e));&#125;listen(arr_url);]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这几天是真的累]]></title>
    <url>%2F2018%2F04%2F28%2F%E8%BF%99%E5%87%A0%E5%A4%A9%E6%98%AF%E7%9C%9F%E7%9A%84%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[项目经理跟跟甲方的需求并没有沟通好，有些事还自以为是的觉得怎样怎样，反映了情况还觉得患者这样很蠢，但事实就是如此，而且还不是偶发。搞得现在产品与需求严重不符，被护士嫌弃了一下午，然后现在这方面的开发还不在，我靠，真是烦！]]></content>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mock模拟数据，拦截请求]]></title>
    <url>%2F2018%2F04%2F15%2Fmock%2F</url>
    <content type="text"><![CDATA[仅为个人学习之用，如有错误欢迎指出 在后端工程师没写好后台的时候怎么办？我们可以用mock模拟数据用于请求，然后把数据格式扔给后端写接口就完事了。 当然除了mock at back-end programmer外，对一些不可确定的数据的效果，也可以用mock模拟。 mockgithub_wiki地址 vue在vue的安装 1npm install mockjs --save 在vue的使用。 12345import Mock from 'mockjs'import loginAPI from './login'Mock.mock(/\/user\/login/, 'post', loginAPI.loginByUsername)//匹配url最后为user/login，请求方式为post的请求时，拦截该请求并返回login.js中loginByUsername方法的return值。]]></content>
      <tags>
        <tag>js</tag>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lnmp隐藏phpmyadmin访问]]></title>
    <url>%2F2018%2F04%2F08%2Flnmp%E9%9A%90%E8%97%8Fphpmyadmin%2F</url>
    <content type="text"><![CDATA[仅为个人学习之用，如有错误欢迎指出 phpmyadmin默认的位置很容易被人才到，一般都是域名或IP/phpmyadmin这个位置，所以有必要为phpmyadmin目录重命名来提高安全性。 123cd /home/wwwroot/default/mv phpmyadmin phpmyadmin-change]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel数据库获取数据]]></title>
    <url>%2F2018%2F04%2F01%2FLaravel%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[Laravel获取表数据Laravel文档 获取多条数据中的某值123456$msgtype=MessageBizConfigModel::where('config_id','=',$apptypeid)-&gt;get();foreach ($msgtype as $msgtypelist)&#123; $typeid = $msgtypelist-&gt;id; $typedesc = $msgtypelist-&gt;desc; array_push($typeArr,['name' =&gt; $typedesc, 'value' =&gt; $typeid]);&#125; 获取多行中的某列值的数组1$msgtype=MessageBizConfigModel::where('config_id','=',$apptypeid)-&gt;pluck('desc'); 获取单行中的某列值1$apptypeid=MessageConfigModel::where('app_id','=',$appid)-&gt;value('id') 获取条件下的行数1$msgerror=MessageRecordModel::where('appkey','=',$appid)-&gt;where('created_at','&lt;=',$enddate)-&gt;where('succeed','=','1')-&gt;count(); 获取表中所有数据1$apptable=MessageConfigModel::all()]]></content>
      <tags>
        <tag>php</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6 异步的学习]]></title>
    <url>%2F2018%2F03%2F30%2Fes6%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[仅为个人学习之用，如有错误欢迎指出 asyncasync 是异步编程的一种解决方案，通过async和await进行处理，await后边跟随Promise对象，当Promise对象状态发生变化时才会执行后边的代码，async函数的return值会成为.then()的参数，只有在async函数里边的所有await都成功时才会执行.then()。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result); //goog&#125;); 为了避免这种情况，我们可以用try…catch方法。 12345678async function myFunction() &#123; try &#123; const symbol = await getStockSymbol(name);; &#125; catch (err) &#123; console.log(err); &#125; return symbol;&#125; promisePromise 是异步编程的一种解决方案，Promise有两个状态变化，即从 pending 变为 resolved 和 pending 变为 rejected，Promise.then()为在状态变化后分别指定resolved状态和rejected状态的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 12345678910111213141516// axios请求function xml(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get('/api'+ ms).then(function(res)=&gt;&#123; resolve() &#125;,function()&#123; reject() &#125;) &#125;);&#125;xml(100).then(function(value) &#123; // success后执行函数的代码&#125;, function(error) &#123; // failure后执行函数的代码&#125;); 不断的执行函数可以 123456789xml(100).then(function(value) &#123; // success后执行函数的代码&#125;, function(error) &#123; // failure后执行函数的代码&#125;).then(function(value) &#123; //上一个函数执行状态完成后 // success后执行函数的代码&#125;, function(error) &#123; // failure后执行函数的代码&#125;); Promise.catch()跟Promise.then()的第二个参数一个意思，都是返回的reject状态，建议用catch()可读性较强。 1Promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;) Promise.finally()为状态变化后都会执行的，不管resolved还是reject都会执行 1Promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 还有Promise.all([])和Promise.race([])方法，Promise.all([])方法为里边的异步都执行完之后才改变状态，promise.all 中任何一个promise 出现错误的时候都会执行reject ，而且获取不到其中是哪个的错误。 1234var p = Promise.all([a,b]);p.then(function(val) &#123; console.log(val);//结果：['aaa','bbb']&#125;); Promise.race([])方法只会输出其中最快完成的方法的值。 1234var p = Promise.race([a,b]);p.then(function(val) &#123; console.log(val);//结果：'bbb'&#125;);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts的上次加载数据清空]]></title>
    <url>%2F2018%2F03%2F23%2FEcharts%E7%9A%84%E4%B8%8A%E6%AC%A1%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E6%B8%85%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[问题今天做图表的时候发现了一个问题，选框每次选中都切换不同的数据，数据是从后台查询获取的，后台返回了数据每次渲染都没有问题，但是后台返回数据新的数据的时候，渲染图表的时候series依旧保存了以前的数据。 然后我试了几种方法都没有成功 123myChart.setOption(option,true);//errorseries：[],//error 只有myChart.clear()把所有的myChart配置给清除了。所以只好每次加载之前.clear()掉之前的，然后再重新再输出一遍myChart的配置和获取到的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576$.ajax(&#123; url:'&#123;&#123; proName &#125;&#125;/message/msganalysis/msgline', type:'POST', dataType:'JSON', data:&#123; startDate:startDate, endDate:endDate, appid:$(".onTitle").attr('name') &#125;, async:false,//同步请求，虽然很卡，但没办法。 success:function (dataajax) &#123; if(dataajax.code==200)&#123; console.log(dataajax); let name_arr=[]; for(let name of dataajax.data)&#123; name_arr.push(name.name); &#125; myChart_line.setOption(&#123; color: ['#32cd32', '#87cefa', '#da70d6', '#6495ed', '#cd5c5c', '#ffa500', '#40e0d0', '#1e90ff', '#ff6347', '#7b68ee', '#00fa9a', '#ffd700', '#6699FF', '#ff6666', '#3cb371', '#b8860b', '#30e0e0'],//颜色库 title: &#123; text: '趋势图' &#125;, tooltip: &#123; trigger: 'axis' &#125;, toolbox: &#123; show : true, feature : &#123; mark : &#123;show: true&#125;, dataView : &#123;show: true, readOnly: false&#125;, magicType : &#123;show: true, type: ['line', 'bar']&#125;, restore : &#123;show: true&#125;, saveAsImage : &#123;show: true&#125; &#125; &#125;, legend: &#123; data:name_arr &#125;, grid: &#123; left: '3%', right: '4%', bottom: '20%', containLabel: true &#125;, xAxis: &#123; type: 'category', boundaryGap: false, axisLabel: &#123; //X轴刻度配置 interval: 0, //0：表示全部显示不间隔；auto:表示自动根据刻度个数和宽度自动设置间隔个数 rotate:45, margin:10, textStyle: &#123; fontSize:'10' &#125; &#125;, //nameRotate:60, data:dataajax.date &#125;, yAxis: &#123; type: 'value' &#125;, series: dataajax.data, &#125;); &#125;else&#123; alert(dataajax.msg); &#125; &#125;, error:function(e)&#123; console.log(e); &#125;&#125;);]]></content>
      <tags>
        <tag>js</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts中x轴文字过长导致重叠]]></title>
    <url>%2F2018%2F03%2F15%2FEcharts%E4%B8%ADx%E8%BD%B4%E6%96%87%E5%AD%97%E8%BF%87%E9%95%BF%E5%AF%BC%E8%87%B4%E9%87%8D%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[Echarts的xAxisEcharts的线图实例 Echarts的配置项 1234567891011121314xAxis: &#123; type: 'category', boundaryGap: false, axisLabel: &#123; //X轴刻度配置 interval: 0, //0：表示全部显示不间隔；auto:表示自动根据刻度个数和宽度自动设置间隔个数 rotate:45, //倾斜45度 margin:10, //与x轴线的距离 textStyle: &#123; fontSize:'10' //字体的大小 &#125; &#125;, data:[]&#125;,]]></content>
      <tags>
        <tag>js</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[是谁扰乱了我的心弦]]></title>
    <url>%2F2018%2F03%2F13%2F%E6%98%AF%E8%B0%81%E6%89%B0%E4%B9%B1%E4%BA%86%E6%88%91%E7%9A%84%E5%BF%83%E5%BC%A6%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[daterangepicker]]></title>
    <url>%2F2018%2F03%2F08%2Fdaterangepicker%E6%97%A5%E6%9C%9F%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[daterangepicker配置daterangepicker官网 12345678910111213141516171819202122232425$('#business_line').daterangepicker(&#123; format: 'YYYY-MM-DD', //时间类型 startDate :startDate1, //默认开始日期 endDate :endDate1, //默认结束日期 ranges : &#123; //可选择的时间按钮 '最近7日': [moment().subtract('days', 6), moment()], '最近30日': [moment().subtract('days', 29), moment()], '本月': [moment().startOf("month"),moment().endOf("month")], '上个月': [moment().subtract(1,"month").startOf("month"),moment().subtract(1,"month").endOf("month")] &#125;, dateLimit : &#123; days : 30 &#125;, //起止时间的最大间隔 locale : &#123; applyLabel : '确定', //apply按钮名称 cancelLabel : '取消', //cancel按钮名称 fromLabel : '开始日期', //from名称 toLabel : '结束日期', //to名称 customRangeLabel : '其他', //ranges自定义按钮名称 &#125;,maxDate : moment(), //可选择最大时间，今天&#125;, function (start, end, label) &#123; startDate = start.format('YYYY-MM-DD'); endDate = end.format('YYYY-MM-DD');&#125;); daterangepicker某按钮的点击事件例如applyLabel按钮的点击： 12345$('#business_line').on('apply.daterangepicker',function(ev, picker) &#123; startDate=picker.startDate.format('YYYY-MM-DD'); //获取起始时间 endDate=picker.endDate.format('YYYY-MM-DD'); //获取结束时间 get_msgtype(startDate,endDate) //执行函数&#125;);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cnpm的安装和npm的重置]]></title>
    <url>%2F2018%2F03%2F01%2Fcnpm%E5%92%8Cnpm%2F</url>
    <content type="text"><![CDATA[cnpm的安装cnpm在国内比npm快很多。cnpm的安装命令行： 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org npm的重置今天遇到个问题，用npm install命令一直报一些奇奇怪怪的错误，后来才发现是npm镜像的问题。所以重置一下npm。 用来查看npm源： 1$ npm config list 重置npm源： 1$ npm config delete registry 然后再查看源发现已经被重置 12345678910111213PS C:\Users\love&gt; npm config list; cli configsmetrics-registry = &quot;https://registry.npmjs.org/&quot;scope = &quot;&quot;user-agent = &quot;npm/5.7.1 node/v8.9.4 win32 x64&quot;; builtin config undefinedprefix = &quot;C:\\Users\\love\\AppData\\Roaming\\npm&quot;; node bin location = D:\nodejs\node.exe; cwd = C:\Users\love; HOME = C:\Users\love; &quot;npm config ls -l&quot; to show all defaults.]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
</search>
